---
title: "Iris de Fisher"
output: html_notebook
author :  "Pauline Moncoiffé-Brisset"
student_number : 43006993
---
# Initialisation
## Bibliothèques "stats" pour K-means et dendextend pour le saut max
```{r}
library(stats)
library(dendextend)

# silhouette
library(cluster)
```
## Bibliothèque "datasets" et données Iris
```{r}
library(datasets)
data(iris)
```
# 1. Retirer la colonne classe des données
```{r}
iris_data <- iris[, -5]   # colonne 5 = "Species"
```
# 2. Calculer la matrice du carré de la distance euclidienne entre les individus.
```{r}
euclidean_distance_matrix <- dist(iris_data, "euclidean", FALSE, FALSE, p = 2)^2
```
# 3. Définir une fonction nommée « silPartition » 
## Elle calcule l’indice silhouette d’une partition donnée
```{r}
silPartition <- function(partition){ 
  # Doc : https://www.rdocumentation.org/packages/cluster/versions/2.1.4/topics/silhouette
  indice_silhouette <- silhouette(partition, dist(euclidean_distance_matrix))
  return(indice_silhouette)
}
```
# 4. Partitionner l’ensemble des individus en 3 classes par le K-Means direct
```{r}
k <- 3
kmeans_result <- kmeans(iris_data, centers = k)
kmeans_result
cluster_assignments <- kmeans_result$cluster
```
# 5. Appliquer à la partition obtenue la fonction « silPartition »
```{r}
# Appeler silhouette avec les données dans la matrice des carrés
silhouette_index <- silPartition(cluster_assignments)
mean_sil_width <- mean(silhouette_index[, "sil_width"])
cat("Mean Silhouette Width: ", mean_sil_width, "\n")
# Bériche trouve 0.5528
cat("Indice silhouette de la partition K-means :", silhouette_index, "\n")
```
# 6. Définir une fonction nommée « inertieIntraPartition » qui calcule l’inertie intra-classe d’une partition donnée
```{r}
inertieIntraPartition <- function(result) {
  # Doc https://stat.ethz.ch/R-manual/R-devel/library/stats/html/kmeans.html
  # tot.withinss Total within-cluster sum of squares, i.e. sum(withinss)
  return (result$tot.withinss)
}
```
# 7. Appliquer à la partition la fonction « inertieIntraPartition ».
```{r}
inertie <- inertieIntraPartition(kmeans_result)
```
# 8. En utilisant la fonction « hclust », effectuer une classification ascendante hiérarchique de l’ensemble des individus par :
## (a) le lien simple ;
```{r}
cah_simple <- hclust(euclidean_distance_matrix, method = "single")
# Afficher le dendrogramme du lien simple
plot(cah_simple, main = "Lien simple")
```
## (b) le lien moyen ;
```{r}
cah_average <- hclust(euclidean_distance_matrix, method = "average")
plot(cah_average, main = "Lien moyen")
```
## (c) le lien complet ;
```{r}
cah_complete <- hclust(euclidean_distance_matrix, method = "complete")
plot(cah_complete, main = "Lien complet")
```
# 9. Définir une fonction nommée « sautMax » qui calcule le niveau de coupure correspondant au saut maximum de l’indice de niveau d’une hiérarchie indicée obtenue par « hclust ».
```{r}
sautMax <- function(hclust_obj) {
  dend <- as.dendrogram(hclust_obj)
  # heights <- attr(dend, "height")
  heights <- get_branches_heights(dend)
  max_jump <- max(heights)
  print(max_jump)
  return(max_jump)
}
```
# 10. Dans chacun des cas de la question (8), déterminer la partition correspondant au saut maximum de l’indice de niveau
# (a) Lien simple
```{r}
cut_height_simple <- sautMax(cah_simple)
plot(cah_simple, main = "Where we cut the simple link dendrogram")
# Doc : https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/rect.hclust
rect.hclust(cah_simple, h = cut_height_simple)

# CUT https://stackoverflow.com/questions/41992119/cut-a-dendrogram
cut_simple_dend <- cut(as.dendrogram(cah_simple), h= cut_height_simple)$lower[[2]]
plot(cut_simple_dend, main="Simple link dendrogram cut")


```
# (b) Lien moyen
```{r}
cut_height_average <- sautMax(cah_average)
plot(cah_average, main = "Where we cut the average link dendrogram")
# Doc : https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/rect.hclust
rect.hclust(cah_average, h = cut_height_average)

# CUT https://stackoverflow.com/questions/41992119/cut-a-dendrogram
cut_average_dend <- cut(as.dendrogram(cah_average), h= cut_height_average)$lower[[2]]
cut_average_dend
plot(cut_average_dend, main="Average link dendrogram cut")
```
# (c) Lien complet
```{r}
cut_height_complete <- sautMax(cah_complete)
partition_complete <- cutree(cah_complete, h = cut_height_complete)
cat("Partition at maximum jump (Complete Linkage):", partition_complete, "\n")
```

# 11. Calculer l’indice silhouette de chacune des partitions obtenues à la question (10)
## (a) Lien simple
## (b) Lien moyen
## (c) Lien complet
# 12. Calculer l’inertie intra-classe de chacune des partitions obtenues à la question (10)
## (a) Lien simple
## (b) Lien moyen
## (c) Lien complet